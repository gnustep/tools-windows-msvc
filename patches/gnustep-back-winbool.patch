diff --git a/Source/win32/WIN32Server.m b/Source/win32/WIN32Server.m
index baab917..6e3fcd1 100644
--- a/Source/win32/WIN32Server.m
+++ b/Source/win32/WIN32Server.m
@@ -63,6 +63,21 @@
 
 #include <math.h>
 
+// category for accessing private ivars...
+@interface NSView (_GSPrivate_)
+
+- (struct _rFlagsType) rFlags;
+
+- (NSArray *) cursorRects;
+
+@end
+
+@interface GSTrackingRect (_GSPrivate_)
+
+- (NSRect) rectangle;
+
+@end
+
 // To update the cursor..
 static BOOL update_cursor = NO;
 static BOOL should_handle_cursor = NO;
@@ -187,7 +202,7 @@ BOOL CALLBACK LoadDisplayMonitorInfo(HMONITOR hMonitor,
 - (void) callback: (id)sender
 {
   MSG msg;
-  WINBOOL bRet; 
+  WinBOOL bRet; 
 //NSLog(@"Callback");
   while ((bRet = PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) != 0)
     { 
@@ -2942,9 +2957,9 @@ process_mouse_event(WIN32Server *svr, HWND hwnd, WPARAM wParam, LPARAM lParam,
 
       subview = [[gswin contentView] hitTest: eventLocation];
       
-      if (subview != nil && subview->_rFlags.valid_rects)
+      if (subview != nil && [subview rFlags].valid_rects)
 	{
-	  NSArray *tr = subview->_cursor_rects;
+	  NSArray *tr = [subview cursorRects];
 	  NSUInteger count = [tr count];
 
 	  // Loop through cursor rectangles
@@ -2966,7 +2981,7 @@ process_mouse_event(WIN32Server *svr, HWND hwnd, WPARAM wParam, LPARAM lParam,
 		  /*
 		   * Check for presence of point in rectangle.
 		   */
-		  now = NSMouseInRect(eventLocation, r->rectangle, NO);
+		  now = NSMouseInRect(eventLocation, [r rectangle], NO);
 
 		  // Mouse inside
 		  if (now)
diff --git a/Source/winlib/WIN32FontEnumerator.m b/Source/winlib/WIN32FontEnumerator.m
index def325b..29e0f7c 100644
--- a/Source/winlib/WIN32FontEnumerator.m
+++ b/Source/winlib/WIN32FontEnumerator.m
@@ -33,6 +33,39 @@
 #include "winlib/WIN32FontEnumerator.h"
 #include "windows.h"
 
+
+@interface WIN32FontEnumerator (_GSPrivate_)
+
+- (NSMutableDictionary *) allFontFamilies;
+
+- (NSArray *) allFontNames;
+
+- (void) setAllFontFamilies: (NSMutableDictionary *)d;
+
+- (void) setAllFontNames: (NSArray *)a;
+
+- (NSString *) fontName;
+
+- (const CGFloat *)matrix;
+
+- (NSString *) familyName;
+
+- (NSCharacterSet *) coveredCharacterSet;
+
+- (unsigned) numberOfGlyphs;
+
+- (CGFloat) ascender;
+
+- (CGFloat) descender;
+
+- (BOOL) isFixedPitch;
+
+- (BOOL) isBaseFont;
+
+- (CGFloat) xHeight;
+
+@end
+
 @implementation WIN32FontEnumerator
 
 int win32_font_weight(LONG tmWeight)
@@ -180,13 +213,13 @@ int CALLBACK fontfamilyenum(ENUMLOGFONTEXW *lpelfe, NEWTEXTMETRICEXW *lpntme,
 				     length: wcslen(lpelfe->elfFullName)];
 
   familyName = win32_font_family(fontName);
-  fontDefs = [enumer->allFontFamilies objectForKey: familyName];
+  fontDefs = [[enumer allFontFamilies] objectForKey: familyName];
   if (fontDefs == nil)
     {
       NSArray *fontDef;
 
       fontDefs = [NSMutableArray arrayWithCapacity: 10];
-      [enumer->allFontFamilies setObject: fontDefs forKey: familyName];
+      [[enumer allFontFamilies] setObject: fontDefs forKey: familyName];
       // FIXME: Need to loop over all fonts for this family
       //add_font(fontDefs, fontName, lpelfe, lpntme);
       //enumerate_font(fontDefs, familyName);
@@ -219,7 +252,7 @@ int CALLBACK fontfamilyenum(ENUMLOGFONTEXW *lpelfe, NEWTEXTMETRICEXW *lpntme,
 	nil];
       [fontDefs addObject: fontDef];
 
-      [(NSMutableArray*)(enumer->allFontNames) addObject: fontName];
+      [(NSMutableArray*)([enumer allFontNames]) addObject: fontName];
     }
 
   return 1;
@@ -236,8 +269,8 @@ int CALLBACK fontfamilyenum(ENUMLOGFONTEXW *lpelfe, NEWTEXTMETRICEXW *lpntme,
       int res;
       CREATE_AUTORELEASE_POOL(pool);
 
-      allFontFamilies = [[NSMutableDictionary alloc] init];
-      allFontNames  = [[NSMutableArray alloc] init];
+      [self setAllFontFamilies: [[NSMutableDictionary alloc] init]];
+      [self setAllFontNames: [[NSMutableArray alloc] init]];
 	
       hdc = GetDC(NULL);
       logfont.lfCharSet = DEFAULT_CHARSET;
diff --git a/Source/winlib/WIN32FontInfo.m b/Source/winlib/WIN32FontInfo.m
index 19c52ce..d1d20eb 100644
--- a/Source/winlib/WIN32FontInfo.m
+++ b/Source/winlib/WIN32FontInfo.m
@@ -41,6 +41,64 @@ NSString *win32_font_family(NSString *fontName);
 - (BOOL) setupAttributes;
 @end
 
+@interface WIN32FontInfo (_GSPrivate_)
+
+- (void) setFontName: (NSString *)n;
+
+- (NSString *) fontName;
+
+- (void) setMatrix: (const CGFloat *)m;
+
+- (const CGFloat *)matrix;
+
+- (void) setFamilyName: (NSString *)name;
+
+- (NSString *) familyName;
+
+- (void) setCoveredCharacterSet: (NSCharacterSet *)c;
+
+- (NSCharacterSet *) coveredCharacterSet;
+
+- (void) setNumberOfGlyphs: (unsigned)n;
+
+- (unsigned) numberOfGlyphs;
+
+- (void) setAscender: (CGFloat)a;
+
+- (CGFloat) ascender;
+
+- (void) setDescender: (CGFloat)d;
+
+- (CGFloat) descender;
+
+- (void) setFixedPitch: (BOOL)f;
+
+- (BOOL) isFixedPitch;
+
+- (void) setBaseFont: (BOOL)f;
+
+- (BOOL) isBaseFont;
+
+- (void) setXHeight: (CGFloat)h;
+
+- (CGFloat) xHeight;
+
+- (void) setMaximumAdvancment: (NSSize)s;
+
+- (NSSize) maximumAdvancement;
+
+- (void) setFontBBox: (NSRect)r;
+
+- (void) setWeight: w;
+
+- (int) weight;
+
+- (NSFontTraitMask) traits;
+
+- (void) setTraits: (NSFontTraitMask)t;
+
+@end
+
 @implementation WIN32FontInfo
 
 - initWithFontName: (NSString*)name
@@ -54,8 +112,8 @@ NSString *win32_font_family(NSString *fontName);
     }
 
   [super init];
-  ASSIGN(fontName, name);
-  memcpy(matrix, fmatrix, sizeof(matrix));
+  [self setFontName: name]; // ASSIGN(fontName, name);
+  [self setMatrix: fmatrix]; // memcpy(matrix, fmatrix, sizeof(matrix));
 
   if (![self setupAttributes])
     {
@@ -193,7 +251,7 @@ NSLog(@"No glyph for U%d", c);
 
 - (NSCharacterSet*) coveredCharacterSet
 {
-  if (coveredCharacterSet == nil)
+  if ([super coveredCharacterSet] == nil)
     {
       NSMutableCharacterSet	*ms;
       unsigned	count; 
@@ -222,7 +280,7 @@ NSLog(@"No glyph for U%d", c);
           gs->cbThis = count;
           if ((unsigned)GetFontUnicodeRanges(hdc, gs) == count)
             {
-              numberOfGlyphs = gs->cGlyphsSupported;
+              [super setNumberOfGlyphs: gs->cGlyphsSupported];
               if (gs->flAccel == 1 /* GS_8BIT_INDICES */)
                 {
                   for (count = 0; count < gs->cRanges; count++)
@@ -250,11 +308,11 @@ NSLog(@"No glyph for U%d", c);
         }
       SelectObject(hdc, old);
       DeleteDC(hdc);
-      coveredCharacterSet = [ms copy];
+      [super setCoveredCharacterSet: [ms copy]];
       RELEASE(ms);
     }
 
-  return coveredCharacterSet;
+  return [super coveredCharacterSet];
 }
 
 - (void) drawString: (NSString*)string
@@ -266,7 +324,7 @@ NSLog(@"No glyph for U%d", c);
   old = SelectObject(hdc, hFont);
   TextOutW(hdc,
     p.x,
-    p.y - ascender,
+    p.y - [super ascender],
     (const unichar*)[string cStringUsingEncoding: NSUnicodeStringEncoding],
     [string length]); 
   SelectObject(hdc, old);
@@ -278,7 +336,7 @@ NSLog(@"No glyph for U%d", c);
   HFONT old;
 
   old = SelectObject(hdc, hFont);
-  TextOut(hdc, p.x, p.y - ascender, s, len); 
+  TextOut(hdc, p.x, p.y - [super ascender], s, len); 
   SelectObject(hdc, old);
 }
 
@@ -300,17 +358,17 @@ NSLog(@"No glyph for U%d", c);
     {
       buf[i] = (WORD)s[i];
     }
-  TextOutW(hdc, p.x, p.y - ascender, buf, len); 
+  TextOutW(hdc, p.x, p.y - [super ascender], buf, len); 
   SelectObject(hdc, old);
 }
 
 - (unsigned) numberOfglyphs
 {
-  if (coveredCharacterSet == nil)
+  if ([super coveredCharacterSet] == nil)
     {
       [self coveredCharacterSet];
     }
-  return numberOfGlyphs;
+  return [super numberOfGlyphs];
 }
 
 - (void) appendBezierPathWithGlyphs: (NSGlyph *)glyphs
@@ -437,29 +495,29 @@ NSLog(@"No glyph for U%d", c);
   NSRange range;
 
   //NSLog(@"Creating Font %@ of size %f", fontName, matrix[0]);
-  ASSIGN(familyName, win32_font_family(fontName));
+  [self setFamilyName: win32_font_family([super fontName])]; //;ASSIGN(familyName, win32_font_family([super fontName]));
   memset(&logfont, 0, sizeof(LOGFONT));
   hdc = CreateCompatibleDC(NULL);
   // FIXME This hack gets the font size about right, but what is the real solution?
-  logfont.lfHeight = (int)(matrix[0] * 4 / 3);
+  logfont.lfHeight = (int)([self matrix][0] * 4 / 3);
   //logfont.lfHeight = -MulDiv(matrix[0], GetDeviceCaps(hdc, LOGPIXELSY), 72);
 
-  range = [fontName rangeOfString: @"Bold"];
+  range = [[self fontName] rangeOfString: @"Bold"];
   if (range.length)
     logfont.lfWeight = FW_BOLD;
 
-  range = [fontName rangeOfString: @"Italic"];
+  range = [[self fontName] rangeOfString: @"Italic"];
   if (range.length)
     logfont.lfItalic = 1; 
 
   logfont.lfQuality = DEFAULT_QUALITY;
   wcsncpy(logfont.lfFaceName,
-    (const unichar*)[familyName cStringUsingEncoding: NSUnicodeStringEncoding],
+    (const unichar*)[[super familyName] cStringUsingEncoding: NSUnicodeStringEncoding],
     LF_FACESIZE);
   hFont = CreateFontIndirectW(&logfont);
   if (!hFont)
     {
-      NSLog(@"Could not create font %@", fontName);
+      NSLog(@"Could not create font %@", [self fontName]);
       DeleteDC(hdc);
       return NO;
     }
@@ -470,27 +528,28 @@ NSLog(@"No glyph for U%d", c);
   DeleteDC(hdc);
 
   // Fill the ivars
-  isFixedPitch = TMPF_FIXED_PITCH & metric.tmPitchAndFamily;
-  isBaseFont = NO;
-  ascender = metric.tmAscent;
+  [self setFixedPitch: TMPF_FIXED_PITCH & metric.tmPitchAndFamily];
+  [self setBaseFont: NO];
+  [self setAscender: metric.tmAscent];
   //NSLog(@"Resulted in height %d and ascent %d", metric.tmHeight, metric.tmAscent);
-  descender = -metric.tmDescent;
+  [self setDescender: -metric.tmDescent];
   /* TODO */
-  xHeight = ascender * 0.5;
-  maximumAdvancement = NSMakeSize((float)metric.tmMaxCharWidth, 0.0);
-
-  fontBBox = NSMakeRect((float)(0),
-			(float)(0 - metric.tmAscent),
-			(float)metric.tmMaxCharWidth,
-			(float)metric.tmHeight);
-
-  weight = win32_font_weight(metric.tmWeight);
-
-  traits = 0;
-  if (weight >= 9)
-    traits |= NSBoldFontMask;
+  [self setXHeight: [self ascender] * 0.5];
+  [self setMaximumAdvancement: NSMakeSize((float)metric.tmMaxCharWidth, 0.0)];
+
+  [self setFontBBox: NSMakeRect((float)(0),
+				(float)(0 - metric.tmAscent),
+				(float)metric.tmMaxCharWidth,
+				(float)metric.tmHeight)];
+	
+  [self setWeight: win32_font_weight(metric.tmWeight)];
+
+  [self setTraits: 0];
+  if ([self weight] >= 9)
+    [self setTraits: [self traits] |= NSBoldFontMask];
   else
-    traits |= NSUnboldFontMask;
+    [self setTraits: [self traits] |= NSUnboldFontMask];
+  // traits |= NSUnboldFontMask;
 
   if (metric.tmItalic)
     traits |= NSItalicFontMask;
diff --git a/configure b/configure
index cd97dc9..5158905 100755
--- a/configure
+++ b/configure
@@ -5932,7 +5932,7 @@ else
 fi
 
 if test "$have_gdi32" = yes; then
-  WIN32_LIBS="-lgdi32 -lm"
+  WIN32_LIBS="-lgdi32"
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for main in -lmsimg32" >&5
 $as_echo_n "checking for main in -lmsimg32... " >&6; }
diff --git a/configure.ac b/configure.ac
index 88a80f5..60ca76b 100644
--- a/configure.ac
+++ b/configure.ac
@@ -393,7 +393,7 @@ AC_CHECK_LIB(X11, XInternAtoms,
 #--------------------------------------------------------------------
 AC_CHECK_LIB(gdi32, main, have_gdi32=yes, have_gdi32=no)
 if test "$have_gdi32" = yes; then
-  WIN32_LIBS="-lgdi32 -lm"
+  WIN32_LIBS="-lgdi32"
 fi
 AC_CHECK_LIB(msimg32, main, have_msimg32=yes, have_msimg32=no)
 if test "$have_msimg32" = yes; then
